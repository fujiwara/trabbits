// MIT License
// Copyright (c) 2025 FUJIWARA Shunichiro

package trabbits

import (
	"fmt"
	"log/slog"
	"strings"
	"sync"

	"github.com/fujiwara/trabbits/amqp091"
	rabbitmq "github.com/rabbitmq/amqp091-go"
)

type upstreamChannel struct {
	channel  *rabbitmq.Channel
	destruct []func(ch *rabbitmq.Channel)
}

func (ch *upstreamChannel) Destruct() {
	for _, f := range ch.destruct {
		f(ch.channel)
	}
	ch.destruct = ch.destruct[:0] // clear
}

type Upstream struct {
	conn          *rabbitmq.Connection
	channel       map[uint16]*upstreamChannel
	mu            sync.Mutex
	logger        *slog.Logger
	keyPatterns   []string
	addr          string
	queueAttr     *QueueAttributes
	shutdownFuncs sync.Map
}

func NewUpstream(addr string, conn *rabbitmq.Connection, logger *slog.Logger, conf UpstreamConfig) *Upstream {
	u := &Upstream{
		conn:        conn,
		channel:     make(map[uint16]*upstreamChannel),
		mu:          sync.Mutex{},
		logger:      logger.With("upstream", addr),
		keyPatterns: conf.Routing.KeyPatterns,
		addr:        addr,
		queueAttr:   conf.QueueAttributes,
	}
	metrics.UpstreamTotalConnections.WithLabelValues(addr).Inc()
	metrics.UpstreamConnections.WithLabelValues(addr).Inc()
	return u
}

func (u *Upstream) String() string {
	return u.addr
}

func (u *Upstream) Close() error {
	if u == nil {
		return nil
	}
	for _, ch := range u.channel {
		ch.Destruct()
		// no need to close the upstream channel here because it will be closed by conn.Close()
	}

	if u.conn != nil {
		metrics.UpstreamConnections.WithLabelValues(u.String()).Dec()
		if err := u.conn.Close(); err != nil {
			return fmt.Errorf("failed to close connection: %w", err)
		}
	}
	// all channels are closed by connection.Close(), so no need to close them here
	return nil
}

func (u *Upstream) NewChannel(id uint16) (*rabbitmq.Channel, error) {
	u.mu.Lock()
	defer u.mu.Unlock()
	if _, ok := u.channel[id]; ok {
		return nil, fmt.Errorf("channel %d already exists", id)
	}
	ch, err := u.conn.Channel()
	if err != nil {
		return nil, fmt.Errorf("failed to create upstream channel: %w", err)
	}
	u.channel[id] = &upstreamChannel{
		channel: ch,
	}
	u.logger.Debug("channel created", "id", id)
	return u.channel[id].channel, nil
}

func (u *Upstream) GetChannel(id uint16) (*rabbitmq.Channel, error) {
	u.mu.Lock()
	defer u.mu.Unlock()
	if ch, ok := u.channel[id]; ok {
		u.logger.Debug("got channel", "id", id)
		return ch.channel, nil
	}
	return nil, fmt.Errorf("channel %d not found", id)
}

func (u *Upstream) CloseChannel(id uint16) error {
	u.mu.Lock()
	defer u.mu.Unlock()
	u.logger.Debug("closing channel", "id", id)
	if ch, ok := u.channel[id]; !ok {
		return fmt.Errorf("channel %d not found", id)
	} else {
		ch.Destruct()
		if err := ch.channel.Close(); err != nil {
			return fmt.Errorf("failed to close channel %d: %w", id, err)
		}
	}
	delete(u.channel, id)
	return nil
}

func (u *Upstream) CleanupAutoGeneratedQueue(id uint16, name string) {
	if !strings.HasPrefix(name, AutoGenerateQueueNamePrefix) {
		return
	}
	u.mu.Lock()
	defer u.mu.Unlock()

	fn := func(ch *rabbitmq.Channel) {
		u.logger.Debug("auto-generated queue cleanup at shutdown", "queue", name)
		if _, err := ch.QueueDelete(name, false, false, false); err != nil {
			u.logger.Warn("failed to delete auto-generated queue", "queue", name, "error", err)
		}
	}
	if ch, ok := u.channel[id]; ok {
		ch.destruct = append(ch.destruct, fn)
	}
}

const AutoGenerateQueueNamePrefix = "trabbits.gen-"

// QueueDeclareArgs generates arguments for rabbitmq.QueueDeclare(name, durable, autoDelete, exclusive, noWait bool, args Table)
// noWait is always false because we need to wait for the response from multiple upstreams
func (u *Upstream) QueueDeclareArgs(m *amqp091.QueueDeclare) (name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args rabbitmq.Table) {
	if strings.HasPrefix(m.Queue, AutoGenerateQueueNamePrefix) {
		// auto-generate queue name like amq.gen-xxxxx
		// durable: false, autoDelete: true, exclusive: true because it's the same as amq.gen-xxxxx
		return m.Queue, false, true, true, false, rabbitmq.Table(m.Arguments)
	}
	if attr := u.queueAttr; attr == nil {
		// if no queue attributes, respect the message's attributes (excluding noWait)
		return m.Queue, m.Durable, m.AutoDelete, m.Exclusive, false, rabbitmq.Table(m.Arguments)
	} else {
		u.logger.Debug("overriding queue attributes", "queue", m.Queue, "upstream", u.String(), "attributes", *attr)
		// override the message's attributes with the upstream's configuration
		durable := m.Durable
		if attr.Durable != nil {
			durable = *attr.Durable
		}
		autoDelete := m.AutoDelete
		if attr.AutoDelete != nil {
			autoDelete = *attr.AutoDelete
		}
		exclusive := m.Exclusive
		if attr.Exclusive != nil {
			exclusive = *attr.Exclusive
		}
		arguments := rabbitmq.Table(m.Arguments)
		if attr.Arguments != nil {
			for k, v := range attr.Arguments {
				if v == nil {
					delete(arguments, k)
				} else {
					arguments[k] = v
				}
			}
		}
		return m.Queue, durable, autoDelete, exclusive, false, arguments
	}
}
