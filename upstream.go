// MIT License
// Copyright (c) 2025 FUJIWARA Shunichiro

package trabbits

import (
	"fmt"
	"log/slog"
	"strings"
	"sync"

	"github.com/fujiwara/trabbits/amqp091"
	"github.com/fujiwara/trabbits/config"
	"github.com/fujiwara/trabbits/metrics"
	rabbitmq "github.com/rabbitmq/amqp091-go"
)

type Upstream struct {
	name          string
	address       string
	conn          *rabbitmq.Connection
	channel       map[uint16]*rabbitmq.Channel
	mu            sync.Mutex
	logger        *slog.Logger
	keyPatterns   []string
	queueAttr     *config.QueueAttributes
	queueOpts     *config.QueueOptions
	shutdownFuncs sync.Map
	destruct      []func(*rabbitmq.Channel)
	closeChan     chan *rabbitmq.Error
	metrics       *metrics.Metrics
}

func NewUpstream(conn *rabbitmq.Connection, logger *slog.Logger, conf config.Upstream, address string, metrics *metrics.Metrics) *Upstream {
	u := &Upstream{
		name:        conf.Name,
		address:     address,
		conn:        conn,
		channel:     make(map[uint16]*rabbitmq.Channel),
		mu:          sync.Mutex{},
		logger:      logger.With("upstream", conf.Name, "address", address),
		keyPatterns: conf.Routing.KeyPatterns,
		queueAttr:   conf.QueueAttributes,
		queueOpts:   conf.QueueOptions,
		destruct:    []func(*rabbitmq.Channel){},
		closeChan:   make(chan *rabbitmq.Error, 1),
		metrics:     metrics,
	}
	// Register for connection close notifications if connection is not nil
	if conn != nil {
		conn.NotifyClose(u.closeChan)
	}
	u.metrics.UpstreamTotalConnections.WithLabelValues(address).Inc()
	u.metrics.UpstreamConnections.WithLabelValues(address).Inc()
	return u
}

func (u *Upstream) String() string {
	return u.name
}

// NotifyClose returns a channel that will be closed when the upstream connection is closed
func (u *Upstream) NotifyClose() <-chan *rabbitmq.Error {
	return u.closeChan
}

func (u *Upstream) Close() error {
	if u == nil {
		return nil
	}
	var ch *rabbitmq.Channel
	for _, _ch := range u.channel {
		ch = _ch
		break
	}
	if ch == nil {
		_ch, err := u.conn.Channel()
		if err != nil {
			return fmt.Errorf("failed to create channel: %w", err)
		}
		ch = _ch
	}
	for _, fn := range u.destruct {
		fn(ch)
	}

	if u.conn != nil {
		u.metrics.UpstreamConnections.WithLabelValues(u.address).Dec()
		if err := u.conn.Close(); err != nil {
			return fmt.Errorf("failed to close connection: %w", err)
		}
	}
	// all channels are closed by connection.Close(), so no need to close them here
	return nil
}

func (u *Upstream) NewChannel(id uint16) (*rabbitmq.Channel, error) {
	u.mu.Lock()
	defer u.mu.Unlock()
	if _, ok := u.channel[id]; ok {
		return nil, fmt.Errorf("channel %d already exists", id)
	}
	ch, err := u.conn.Channel()
	if err != nil {
		return nil, fmt.Errorf("failed to create upstream channel: %w", err)
	}
	u.channel[id] = ch
	u.logger.Debug("channel created", "id", id)
	return u.channel[id], nil
}

func (u *Upstream) GetChannel(id uint16) (*rabbitmq.Channel, error) {
	u.mu.Lock()
	defer u.mu.Unlock()
	if ch, ok := u.channel[id]; ok {
		u.logger.Debug("got channel", "id", id)
		return ch, nil
	}
	return nil, fmt.Errorf("channel %d not found", id)
}

func (u *Upstream) CloseChannel(id uint16) error {
	u.mu.Lock()
	defer u.mu.Unlock()
	u.logger.Debug("closing channel", "id", id)
	if ch, ok := u.channel[id]; !ok {
		// channel not found
	} else {
		if err := ch.Close(); err != nil {
			return fmt.Errorf("failed to close channel %d: %w", id, err)
		}
	}
	delete(u.channel, id)
	return nil
}

func (u *Upstream) CleanupAutoGeneratedQueue(name string) {
	if !strings.HasPrefix(name, AutoGenerateQueueNamePrefix) {
		return
	}
	u.mu.Lock()
	defer u.mu.Unlock()

	fn := func(ch *rabbitmq.Channel) {
		u.logger.Debug("auto-generated queue cleanup at shutdown", "queue", name)
		if _, err := ch.QueueDelete(name, false, false, false); err != nil {
			u.logger.Warn("failed to delete auto-generated queue", "queue", name, "error", err)
		}
	}
	u.destruct = append(u.destruct, fn)
}

// RegisterEmulatedAutoDeleteQueue registers a queue for deletion when connection closes
// This emulates auto_delete behavior for durable queues
func (u *Upstream) RegisterEmulatedAutoDeleteQueue(queueName string) {
	u.mu.Lock()
	defer u.mu.Unlock()

	fn := func(ch *rabbitmq.Channel) {
		u.logger.Debug("deleting queue with emulated auto_delete", "queue", queueName)
		if _, err := ch.QueueDelete(queueName, false, false, false); err != nil {
			// Check if error is NOT_FOUND (queue already deleted)
			if amqpErr, ok := err.(*rabbitmq.Error); ok && amqpErr.Code == amqp091.NotFound {
				u.logger.Debug("queue already deleted", "queue", queueName)
				return
			}
			u.logger.Warn("failed to delete emulated auto_delete queue", "queue", queueName, "error", err)
		}
	}
	u.destruct = append(u.destruct, fn)
}

const AutoGenerateQueueNamePrefix = "trabbits.gen-"

// QueueDeclareArgs generates arguments for rabbitmq.QueueDeclare(name, durable, autoDelete, exclusive, noWait bool, args Table)
// noWait is always false because we need to wait for the response from multiple upstreams
func (u *Upstream) QueueDeclareArgs(m *amqp091.QueueDeclare) (name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args rabbitmq.Table) {
	if strings.HasPrefix(m.Queue, AutoGenerateQueueNamePrefix) {
		// auto-generate queue name like amq.gen-xxxxx
		// durable: false, autoDelete: true, exclusive: true because it's the same as amq.gen-xxxxx
		return m.Queue, false, true, true, false, rabbitmq.Table(m.Arguments)
	}
	if attr := u.queueAttr; attr == nil {
		// if no queue attributes, respect the message's attributes (excluding noWait)
		return m.Queue, m.Durable, m.AutoDelete, m.Exclusive, false, rabbitmq.Table(m.Arguments)
	} else {
		u.logger.Debug("overriding queue attributes", "queue", m.Queue, "attributes", *attr)
		// override the message's attributes with the upstream's configuration
		durable := m.Durable
		if attr.Durable != nil {
			durable = *attr.Durable
		}
		autoDelete := m.AutoDelete
		if attr.AutoDelete != nil {
			autoDelete = *attr.AutoDelete
		}
		exclusive := m.Exclusive
		if attr.Exclusive != nil {
			exclusive = *attr.Exclusive
		}
		arguments := rabbitmq.Table(m.Arguments)
		if attr.Arguments != nil {
			if arguments == nil {
				arguments = rabbitmq.Table{}
			}
			for k, v := range attr.Arguments {
				if v == nil {
					delete(arguments, k)
				} else {
					arguments[k] = v
				}
			}
		}
		return m.Queue, durable, autoDelete, exclusive, false, arguments
	}
}

// QueueDeclareWithTryPassive attempts a passive declare first, then falls back to normal declare if queue doesn't exist
func (u *Upstream) QueueDeclareWithTryPassive(ch *rabbitmq.Channel, m *amqp091.QueueDeclare) (rabbitmq.Queue, error) {
	queueExisted := false

	if u.queueOpts != nil && u.queueOpts.TryPassive {
		// Try passive declare first to check if queue exists
		u.logger.Debug("trying passive declare", "queue", m.Queue)
		q, err := ch.QueueDeclare(m.Queue, false, false, false, true, nil)
		if err == nil {
			u.logger.Debug("passive declare succeeded", "queue", m.Queue)
			queueExisted = true
			// Don't register for emulation if queue already existed
			return q, nil
		}
		// Check if error is NOT_FOUND (404)
		if amqpErr, ok := err.(*rabbitmq.Error); ok && amqpErr.Code == amqp091.NotFound {
			u.logger.Debug("queue not found, falling back to normal declare", "queue", m.Queue)
			// Fall through to normal declare
		} else {
			// Other errors should be returned
			return rabbitmq.Queue{}, fmt.Errorf("passive declare failed: %w", err)
		}
	}

	// Normal declare with configured attributes
	q, err := ch.QueueDeclare(u.QueueDeclareArgs(m))
	if err != nil {
		return q, err
	}

	// Check if we should emulate auto_delete for this queue
	if !queueExisted && u.shouldEmulateAutoDelete(m) {
		u.logger.Debug("registering queue for emulated auto_delete", "queue", q.Name)
		u.RegisterEmulatedAutoDeleteQueue(q.Name)
	}

	return q, nil
}

// shouldEmulateAutoDelete checks if auto_delete emulation should be enabled for this queue
func (u *Upstream) shouldEmulateAutoDelete(m *amqp091.QueueDeclare) bool {
	// Check if emulation is enabled in config
	if u.queueOpts == nil || !u.queueOpts.EmulateAutoDelete {
		return false
	}

	// Check if client requested auto_delete=true
	if !m.AutoDelete {
		return false
	}

	// Check if we're overriding auto_delete to false
	// If AutoDelete is nil (not specified), we keep client's value, so no emulation needed
	// If AutoDelete is true, no emulation needed (real auto_delete)
	// If AutoDelete is false, we need emulation
	if u.queueAttr == nil || u.queueAttr.AutoDelete == nil {
		return false // No override, client's value is used (real auto_delete)
	}
	if *u.queueAttr.AutoDelete {
		return false // Real auto_delete, no emulation needed
	}

	return true
}
