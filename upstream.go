// MIT License
// Copyright (c) 2025 FUJIWARA Shunichiro

package trabbits

import (
	"fmt"
	"log/slog"
	"strings"
	"sync"

	"github.com/fujiwara/trabbits/amqp091"
	rabbitmq "github.com/rabbitmq/amqp091-go"
)

type Upstream struct {
	name          string
	address       string
	conn          *rabbitmq.Connection
	channel       map[uint16]*rabbitmq.Channel
	mu            sync.Mutex
	logger        *slog.Logger
	keyPatterns   []string
	queueAttr     *QueueAttributes
	shutdownFuncs sync.Map
	destruct      []func(*rabbitmq.Channel)
	closeChan     chan *rabbitmq.Error
}

func NewUpstream(conn *rabbitmq.Connection, logger *slog.Logger, conf UpstreamConfig, address string) *Upstream {
	u := &Upstream{
		name:        conf.Name,
		address:     address,
		conn:        conn,
		channel:     make(map[uint16]*rabbitmq.Channel),
		mu:          sync.Mutex{},
		logger:      logger.With("upstream", conf.Name, "address", address),
		keyPatterns: conf.Routing.KeyPatterns,
		queueAttr:   conf.QueueAttributes,
		destruct:    []func(*rabbitmq.Channel){},
		closeChan:   make(chan *rabbitmq.Error, 1),
	}
	// Register for connection close notifications if connection is not nil
	if conn != nil {
		conn.NotifyClose(u.closeChan)
	}
	metrics.UpstreamTotalConnections.WithLabelValues(address).Inc()
	metrics.UpstreamConnections.WithLabelValues(address).Inc()
	return u
}

func (u *Upstream) String() string {
	return u.name
}

// NotifyClose returns a channel that will be closed when the upstream connection is closed
func (u *Upstream) NotifyClose() <-chan *rabbitmq.Error {
	return u.closeChan
}

func (u *Upstream) Close() error {
	if u == nil {
		return nil
	}
	var ch *rabbitmq.Channel
	for _, _ch := range u.channel {
		ch = _ch
		break
	}
	if ch == nil {
		_ch, err := u.conn.Channel()
		if err != nil {
			return fmt.Errorf("failed to create channel: %w", err)
		}
		ch = _ch
	}
	for _, fn := range u.destruct {
		fn(ch)
	}

	if u.conn != nil {
		metrics.UpstreamConnections.WithLabelValues(u.address).Dec()
		if err := u.conn.Close(); err != nil {
			return fmt.Errorf("failed to close connection: %w", err)
		}
	}
	// all channels are closed by connection.Close(), so no need to close them here
	return nil
}

func (u *Upstream) NewChannel(id uint16) (*rabbitmq.Channel, error) {
	u.mu.Lock()
	defer u.mu.Unlock()
	if _, ok := u.channel[id]; ok {
		return nil, fmt.Errorf("channel %d already exists", id)
	}
	ch, err := u.conn.Channel()
	if err != nil {
		return nil, fmt.Errorf("failed to create upstream channel: %w", err)
	}
	u.channel[id] = ch
	u.logger.Debug("channel created", "id", id)
	return u.channel[id], nil
}

func (u *Upstream) GetChannel(id uint16) (*rabbitmq.Channel, error) {
	u.mu.Lock()
	defer u.mu.Unlock()
	if ch, ok := u.channel[id]; ok {
		u.logger.Debug("got channel", "id", id)
		return ch, nil
	}
	return nil, fmt.Errorf("channel %d not found", id)
}

func (u *Upstream) CloseChannel(id uint16) error {
	u.mu.Lock()
	defer u.mu.Unlock()
	u.logger.Debug("closing channel", "id", id)
	if ch, ok := u.channel[id]; !ok {
		// channel not found
	} else {
		if err := ch.Close(); err != nil {
			return fmt.Errorf("failed to close channel %d: %w", id, err)
		}
	}
	delete(u.channel, id)
	return nil
}

func (u *Upstream) CleanupAutoGeneratedQueue(name string) {
	if !strings.HasPrefix(name, AutoGenerateQueueNamePrefix) {
		return
	}
	u.mu.Lock()
	defer u.mu.Unlock()

	fn := func(ch *rabbitmq.Channel) {
		u.logger.Debug("auto-generated queue cleanup at shutdown", "queue", name)
		if _, err := ch.QueueDelete(name, false, false, false); err != nil {
			u.logger.Warn("failed to delete auto-generated queue", "queue", name, "error", err)
		}
	}
	u.destruct = append(u.destruct, fn)
}

const AutoGenerateQueueNamePrefix = "trabbits.gen-"

// QueueDeclareArgs generates arguments for rabbitmq.QueueDeclare(name, durable, autoDelete, exclusive, noWait bool, args Table)
// noWait is always false because we need to wait for the response from multiple upstreams
func (u *Upstream) QueueDeclareArgs(m *amqp091.QueueDeclare) (name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args rabbitmq.Table) {
	if strings.HasPrefix(m.Queue, AutoGenerateQueueNamePrefix) {
		// auto-generate queue name like amq.gen-xxxxx
		// durable: false, autoDelete: true, exclusive: true because it's the same as amq.gen-xxxxx
		return m.Queue, false, true, true, false, rabbitmq.Table(m.Arguments)
	}
	if attr := u.queueAttr; attr == nil {
		// if no queue attributes, respect the message's attributes (excluding noWait)
		return m.Queue, m.Durable, m.AutoDelete, m.Exclusive, false, rabbitmq.Table(m.Arguments)
	} else {
		u.logger.Debug("overriding queue attributes", "queue", m.Queue, "upstream", u.String(), "attributes", *attr)
		// override the message's attributes with the upstream's configuration
		durable := m.Durable
		if attr.Durable != nil {
			durable = *attr.Durable
		}
		autoDelete := m.AutoDelete
		if attr.AutoDelete != nil {
			autoDelete = *attr.AutoDelete
		}
		exclusive := m.Exclusive
		if attr.Exclusive != nil {
			exclusive = *attr.Exclusive
		}
		arguments := rabbitmq.Table(m.Arguments)
		if attr.Arguments != nil {
			for k, v := range attr.Arguments {
				if v == nil {
					delete(arguments, k)
				} else {
					arguments[k] = v
				}
			}
		}
		return m.Queue, durable, autoDelete, exclusive, false, arguments
	}
}
